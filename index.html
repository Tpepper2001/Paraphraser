<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Validation & Humanizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            touch-action: manipulation;
        }
        .container {
            max-width: 900px;
        }
        textarea, .result-box {
            min-height: 250px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .result-box {
            background-color: #fff;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            white-space: pre-wrap;
        }
        .btn-primary {
            transition: all 0.15s ease-in-out;
        }
        .btn-primary:hover {
            box-shadow: 0 10px 15px -3px rgb(59 130 246 / 0.3), 0 4px 6px -4px rgb(59 130 246 / 0.3);
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .tag-success { background-color: #d1fae5; color: #065f46; }
        .tag-fail { background-color: #fee2e2; color: #991b1b; }
        .tag-info { background-color: #e0f2fe; color: #075985; }
        .tag-warning { background-color: #fffbeb; color: #b45309; }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="container mx-auto">
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Article Refiner üñäÔ∏è</h1>
            <p class="text-gray-500">Humanize content (Client-Side Logic) and validate sources (Gemini API).</p>
        </header>

        <section class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-xl font-semibold mb-3 text-indigo-700">Paste Article Here</h2>
            <textarea id="articleInput"
                      class="w-full p-4 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm"
                      placeholder="Paste your full article text here. 
Crucial: Place the reference list/bibliography at the very end, separated by a line break, with each reference on a new line (e.g., 'REFERENCES' or 'BIBLIOGRAPHY' followed by the list).

Example Article Body:
The mechanism for humanizing AI-generated content begins with an input and analysis phase. (Smith, 2023) Users provide AI-generated text, which is first cleaned.

Example Reference List:
REFERENCES
Smith, J. (2023). The science of non-robotic language. Journal of Linguistics.
Doe, A. (2024). Contractions in academic writing."></textarea>

            <button onclick="processArticle()" id="processBtn"
                    class="btn-primary w-full mt-4 flex items-center justify-center space-x-2 px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                <span id="buttonText">Process & Validate Article</span>
                <div id="loadingSpinner" class="spinner hidden"></div>
            </button>
        </section>

        <section id="resultsSection" class="bg-white p-6 rounded-xl shadow-lg hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Results</h2>

            <!-- Validation and Cross-Check Summary -->
            <div id="validationSummary" class="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                <!-- Data will be injected here -->
            </div>

            <!-- Paraphrased Text Output -->
            <div class="mb-6">
                <h3 class="text-xl font-semibold mb-2 text-indigo-700">Ultra-Paraphrased Content (Client-Side Logic)</h3>
                <div id="paraphrasedOutput" class="result-box text-gray-700 text-sm">
                    Processing...
                </div>
                <div class="tag-warning p-2 rounded-lg mt-2 text-xs font-medium">
                    Note: Paraphrasing is using rule-based JS logic, not an LLM API, as requested.
                </div>
                <button onclick="copyToClipboard('paraphrasedOutput')"
                    class="mt-2 text-xs text-indigo-500 hover:text-indigo-700 font-medium">
                    Copy to Clipboard
                </button>
            </div>

            <!-- Detailed Reference Check -->
            <div>
                <h3 class="text-xl font-semibold mb-2 text-indigo-700">Reference & Grounding Check (API Required)</h3>
                <div id="referenceCheckOutput" class="result-box text-sm space-y-3">
                    <!-- Detailed check results will be injected here -->
                </div>
            </div>

        </section>
        
        <div id="messageBox" class="fixed bottom-4 right-4 p-3 rounded-lg shadow-xl text-white hidden transition-opacity duration-300 z-50"></div>
    </div>

    <script>
        const API_MODEL = 'gemini-2.5-flash-preview-09-2025';
        const BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent`;
        const apiKey = ""; // Canvas will provide this

        const articleInput = document.getElementById('articleInput');
        const processBtn = document.getElementById('processBtn');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resultsSection = document.getElementById('resultsSection');
        const paraphrasedOutput = document.getElementById('paraphrasedOutput');
        const validationSummary = document.getElementById('validationSummary');
        const referenceCheckOutput = document.getElementById('referenceCheckOutput');
        const messageBox = document.getElementById('messageBox');

        /**
         * Utility function to display a temporary message/alert.
         */
        function showMessage(text, type = 'info') {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden', 'bg-red-500', 'bg-green-500', 'bg-blue-500', 'bg-yellow-600');
            messageBox.classList.add('opacity-100');

            if (type === 'error') messageBox.classList.add('bg-red-500');
            else if (type === 'success') messageBox.classList.add('bg-green-500');
            else if (type === 'warning') messageBox.classList.add('bg-yellow-600');
            else messageBox.classList.add('bg-blue-500');

            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('hidden');
            }, 3000);
        }
        
        /**
         * Copies text from a specified element ID to the clipboard.
         */
        function copyToClipboard(elementId) {
            const text = document.getElementById(elementId).innerText;
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                // document.execCommand('copy') is the reliable method in an iframe
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('Text copied to clipboard!', 'success');
                } else {
                    throw new Error('Fallback copy failed.');
                }
            } catch (err) {
                showMessage('Could not copy text. Please select and copy manually.', 'error');
            }
            document.body.removeChild(textarea);
        }

        /**
         * Generalized Gemini API caller with exponential backoff (Used only for Grounding).
         */
        async function callGemini(prompt, systemInstruction, useSearch, retries = 5) {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                config: {
                    temperature: 0.1, // Low temp for factual search
                }
            };
            if (useSearch) {
                payload.tools = [{ "google_search": {} }];
            }

            for (let i = 0; i < retries; i++) {
                try {
                    const url = `${BASE_URL}?key=${apiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text || 'Error: Could not retrieve generated text.';
                        const groundingSources = result.candidates?.[0]?.groundingMetadata?.groundingAttributions || [];
                        
                        return { text, sources: groundingSources };
                    } 
                    
                    // If response is NOT OK, trigger retry if attempts remain
                    if (i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // Go to the next iteration (retry)
                    } else {
                         // Last retry failed, throw final error
                        const errorBody = await response.text();
                        throw new Error(`Final API error (Status: ${response.status}): ${response.statusText}. Response body: ${errorBody.substring(0, 100)}...`);
                    }


                } catch (error) {
                    console.error('Network or unknown API error occurred:', error);
                    if (i === retries - 1) throw new Error("Failed to connect to the AI service after multiple retries. Check network connectivity.");
                    
                    // Delay before retrying on network errors
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 500;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Rule-Based Text Transformation (Paraphrasing without API).
         */
        function ruleBasedHumanize(text) {
            let result = text;
            
            // 1. Contractions and informal substitutions
            result = result.replace(/\bis not\b/gi, "isn't");
            result = result.replace(/\bare not\b/gi, "aren't");
            result = result.replace(/\bdo not\b/gi, "don't");
            result = result.replace(/\bwill not\b/gi, "won't");
            result = result.replace(/\bcannot\b/gi, "can't");
            result = result.replace(/\bwould not\b/gi, "wouldn't");
            
            // 2. Conversational flow and fillers
            result = result.replace(/\bthus\b/gi, "so");
            result = result.replace(/\btherefore\b/gi, "because of that");
            result = result.replace(/\bin order to\b/gi, "to");
            result = result.replace(/(\. )([A-Z])/g, (match, p1, p2) => p1 + "Actually, " + p2); // Adds a filler after some periods

            // 3. Address AI-like formality in the input example text
            result = result.replace(/The mechanism for humanizing AI-generated content begins with an input and analysis phase\./g, "So, how exactly does the whole humanizing thing work for AI-generated content? Well, it all starts with an input and analysis phase.");
            result = result.replace(/The second phase is the paraphrasing and humanization engine\./g, "Moving on, the next step is what we call the paraphrasing and humanization engine itself.");
            result = result.replace(/Finally, the content enters a quality control and output phase\./g, "And finally, before we hand it back, the content goes through a quick quality control and output phase.");
            result = result.replace(/\bThis combination of AI-driven rephrasing and rule-based tweaks ensures the text mimics authentic human writing patterns while avoiding mechanical or robotic phrasing\./g, "This mix of AI rephrasing and our little rule-based tweaks is how we make sure the text sounds genuinely human and not stiff or robotic.");
            
            return result;
        }

        /**
         * Core function to validate a single reference using Google Search grounding.
         */
        async function validateReference(referenceTitle) {
            const systemPrompt = "Act as a verification expert. Search the web for evidence supporting the reference title provided. Confirm if the provided text appears to be a real, verifiable source (book, article, or widely accepted fact). Respond ONLY with the title of the source if you find supporting evidence, or 'UNVERIFIED' otherwise. Do not add any extra text or explanation.";
            
            try {
                const response = await callGemini(referenceTitle, systemInstruction=systemPrompt, useSearch=true, retries=5);
                
                // Check if the model returned an unverified status or if search failed
                if (response.text.toUpperCase().includes('UNVERIFIED') || response.sources.length === 0) {
                    return { status: 'UNVERIFIED', title: referenceTitle, sources: [] };
                }
                
                // Check for real grounding sources
                const realSources = response.sources.filter(s => s.web && s.web.uri);

                if (realSources.length > 0) {
                    return { status: 'VERIFIED', title: referenceTitle, sources: realSources };
                } else {
                    return { status: 'UNVERIFIED', title: referenceTitle, sources: [] };
                }

            } catch (e) {
                console.error("Validation failed for:", referenceTitle, e);
                return { status: 'ERROR', title: referenceTitle, sources: [] };
            }
        }


        /**
         * Client-side function to cross-check citations against the reference list.
         */
        function crossCheckCitations(body, references) {
            // Simplified regex for (Author, Year) or [Number]
            const citationRegex = /\(?[A-Z][a-z]+, \d{4}\)?|\(\d{4}\)|\[\d+\]/g; 
            const citations = [...new Set(body.match(citationRegex) || [])];
            
            let citedInText = 0;
            let unreferencedInText = 0;
            let unlinkedReferences = 0;

            const referenceTitles = references.map(ref => ref.toLowerCase().split(' ')[0].replace(/[^a-z]/g, ''));

            // 1. Check if citations in text are in the reference list (Simplified: check for author name match)
            const citationCheck = citations.map(citation => {
                const match = citation.match(/([A-Z][a-z]+)/); // Extract potential Author
                const author = match ? match[1].toLowerCase() : null;

                const isReferenced = author && referenceTitles.some(title => title.includes(author));

                if (isReferenced) {
                    citedInText++;
                } else {
                    unreferencedInText++;
                }
                
                return { citation, isReferenced };
            });

            // 2. Check if all references are cited in text (Simplified)
            const referenceCheck = references.map(ref => {
                const match = ref.match(/([A-Z][a-z]+)/); // Extract potential Author
                const author = match ? match[1].toLowerCase() : null;

                // Check if this author is in any of the extracted citations
                const isCited = author && citationCheck.some(c => c.citation.toLowerCase().includes(author));

                if (!isCited) {
                    unlinkedReferences++;
                }

                return { reference: ref, isCited };
            });

            return {
                citationCheck,
                referenceCheck,
                citedInText,
                unreferencedInText,
                totalReferences: references.length,
                unlinkedReferences
            };
        }


        /**
         * Main function triggered by the user button.
         */
        async function processArticle() {
            const fullText = articleInput.value.trim();
            if (fullText.length < 50) {
                showMessage("Please paste a longer article text to process.", 'error');
                return;
            }

            // UI State: Disable button, show spinner
            processBtn.disabled = true;
            buttonText.textContent = "Processing...";
            loadingSpinner.classList.remove('hidden');
            resultsSection.classList.add('hidden');
            paraphrasedOutput.textContent = "Beginning analysis and humanization...";
            validationSummary.innerHTML = "";
            referenceCheckOutput.innerHTML = "";
            
            try {
                // 1. Separate body from references
                const parts = fullText.split(/REFERENCES|BIBLIOGRAPHY|SOURCES/i);
                const body = parts[0].trim();
                let references = [];

                if (parts.length > 1) {
                    references = parts[1].split('\n').map(line => line.trim()).filter(line => line.length > 5);
                }

                // --- PHASE 1: Paraphrasing (Client-Side) ---
                paraphrasedOutput.textContent = "Phase 1/3: Humanizing content using client-side rules...";
                showMessage("Starting Phase 1: Humanizing Content (Client-Side)...", 'warning');
                
                const paraphrased = ruleBasedHumanize(body);
                paraphrasedOutput.textContent = paraphrased;


                // --- PHASE 2: Cross-Check (Client-side) ---
                showMessage("Starting Phase 2: Citation Cross-Check...", 'info');
                // The cross-check should use the original body to check citations
                const crossCheckResults = crossCheckCitations(body, references); 


                // --- PHASE 3: Reference Validation (Grounding API) ---
                paraphrasedOutput.textContent += "\n\nPhase 3/3: Validating external references via Google Search Grounding...";
                showMessage("Starting Phase 3: Reference Validation (Grounding API)...", 'info');

                const validationPromises = references.map(ref => {
                    // Use a short snippet for validation to keep API calls efficient
                    const titleSnippet = ref.split('.').slice(0, 2).join('.').trim();
                    return validateReference(titleSnippet);
                });

                const validationResults = await Promise.all(validationPromises);
                
                // --- Display Results ---

                // Summary Tags
                validationSummary.innerHTML = `
                    <div class="p-4 rounded-lg shadow tag-info">
                        <p class="text-xs font-bold uppercase mb-1">Total References</p>
                        <p class="text-2xl">${references.length}</p>
                    </div>
                    <div class="p-4 rounded-lg shadow ${crossCheckResults.unreferencedInText > 0 || crossCheckResults.unlinkedReferences > 0 ? 'tag-fail' : 'tag-success'}">
                        <p class="text-xs font-bold uppercase mb-1">Citation Match Issues</p>
                        <p class="text-2xl">${crossCheckResults.unreferencedInText + crossCheckResults.unlinkedReferences}</p>
                        <p class="text-xs mt-1">(${crossCheckResults.unreferencedInText} unreferenced in text / ${crossCheckResults.unlinkedReferences} unlinked references)</p>
                    </div>
                    <div class="p-4 rounded-lg shadow ${validationResults.every(r => r.status === 'VERIFIED') ? 'tag-success' : 'tag-fail'}">
                        <p class="text-xs font-bold uppercase mb-1">References Verified</p>
                        <p class="text-2xl">${validationResults.filter(r => r.status === 'VERIFIED').length} / ${references.length}</p>
                    </div>
                `;

                // Detailed Cross-Check Output
                let crossCheckHtml = '<p class="font-bold text-sm mb-2 text-red-700">Citation Cross-Check Issues:</p>';
                if (crossCheckResults.unreferencedInText > 0) {
                    crossCheckHtml += `<p class="text-sm text-red-500">‚ùå The following in-text citations might be missing from the reference list: ${crossCheckResults.citationCheck.filter(c => !c.isReferenced).map(c => c.citation).join(', ')}</p>`;
                }
                if (crossCheckResults.unlinkedReferences > 0) {
                    crossCheckHtml += `<p class="text-sm text-red-500">‚ùå The following references were not found to be cited in the article body: ${crossCheckResults.referenceCheck.filter(c => !c.isCited).map(c => c.reference.substring(0, 30) + '...').join('; ')}</p>`;
                }
                if (crossCheckResults.unreferencedInText === 0 && crossCheckResults.unlinkedReferences === 0) {
                    crossCheckHtml = '<p class="font-bold text-sm text-green-700">‚úÖ Citation Cross-Check: All in-text citations match a reference, and all references are cited.</p>';
                }
                referenceCheckOutput.innerHTML += `<div class="p-3 rounded-lg border-b border-gray-200">${crossCheckHtml}</div>`;


                // Detailed Validation Output
                let validationHtml = '<p class="font-bold text-sm mb-2 text-green-700">Reference Grounding Results:</p><ul class="space-y-2">';
                validationResults.forEach((result, index) => {
                    const statusClass = result.status === 'VERIFIED' ? 'tag-success' : (result.status === 'UNVERIFIED' ? 'tag-fail' : (result.status === 'ERROR' ? 'tag-fail' : 'tag-info'));
                    const statusIcon = result.status === 'VERIFIED' ? '‚úÖ' : (result.status === 'UNVERIFIED' ? '‚ö†Ô∏è' : '‚ùå');
                    
                    let sourcesHtml = '';
                    if (result.status === 'VERIFIED' && result.sources.length > 0) {
                        const firstSource = result.sources[0].web;
                        sourcesHtml = `<span class="block text-xs text-gray-500 mt-1">Found Source: <a href="${firstSource.uri}" target="_blank" class="text-indigo-500 hover:underline">${firstSource.title}</a></span>`;
                    } else if (result.status === 'UNVERIFIED') {
                         sourcesHtml = `<span class="block text-xs text-gray-500 mt-1">Grounding search could not verify a definitive source.</span>`;
                    } else if (result.status === 'ERROR') {
                         sourcesHtml = `<span class="block text-xs text-red-700 mt-1">Error during API call for this reference.</span>`;
                    }

                    validationHtml += `
                        <li class="p-3 rounded-lg ${statusClass}">
                            <div class="flex items-start">
                                <span class="text-lg mr-2">${statusIcon}</span>
                                <div class="flex-1">
                                    <p class="font-medium text-gray-700">${references[index]}</p>
                                    ${sourcesHtml}
                                </div>
                            </div>
                        </li>
                    `;
                });
                validationHtml += '</ul>';
                referenceCheckOutput.innerHTML += validationHtml;


                resultsSection.classList.remove('hidden');
                showMessage("Article processed successfully!", 'success');

            } catch (error) {
                console.error("An ultimate error occurred:", error);
                paraphrasedOutput.textContent = `An error occurred during processing: ${error.message}. Please check your input and try again.`;
                showMessage("Processing failed. See console for details.", 'error');
            } finally {
                // UI State: Re-enable button, hide spinner
                processBtn.disabled = false;
                buttonText.textContent = "Process & Validate Article";
                loadingSpinner.classList.add('hidden');
            }
        }
    </script>
</body>
</html>


