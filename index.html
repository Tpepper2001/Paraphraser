<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Validation & Humanizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Adopted styles from user's template, integrated with utility classes */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: #333;
            touch-action: manipulation;
        }
        .container {
            max-width: 900px;
            margin: 40px auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        header {
            background: #4a00e0;
            color: white;
            padding: 30px;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 700;
        }
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 8px;
        }
        .main {
            padding: 30px;
        }
        .input-group, .output-group {
            margin-bottom: 25px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }
        textarea, .result-box {
            width: 100%;
            height: 180px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            resize: vertical;
            transition: all 0.3s;
            box-sizing: border-box;
            min-height: 200px; /* Ensure readability */
        }
        textarea:focus {
            outline: none;
            border-color: #4a00e0;
            box-shadow: 0 0 0 3px rgba(74, 0, 224, 0.2);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #processBtn {
            background: #8e2de2;
            color: white;
            flex-grow: 1;
        }
        #processBtn:hover {
            background: #7c1fd1;
            transform: translateY(-2px);
        }
        #copyBtn {
            background: #51cf66;
            color: white;
        }
        #copyBtn:hover {
            background: #40c957;
        }
        select {
            padding: 10px 14px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 15px;
        }
        .strength-meter {
            margin-top: 10px;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
        }
        .strength-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffd43b, #ff6b6b, #51cf66);
            transition: width 0.4s ease;
        }
        .tips {
            background: #f8f9fa;
            padding: 18px;
            border-radius: 10px;
            margin-top: 25px;
            border-left: 5px solid #4a00e0;
            font-size: 0.95em;
            line-height: 1.6;
        }
        .tips h3 {
            margin-top: 0;
            color: #4a00e0;
        }
        footer {
            text-align: center;
            padding: 20px;
            background: #f1f3f5;
            color: #666;
            font-size: 0.9em;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .tag-success { background-color: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
        .tag-fail { background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }
        .tag-info { background-color: #e0f2fe; color: #075985; border: 1px solid #bae6fd; }
        .tag-warning { background-color: #fffbeb; color: #b45309; border: 1px solid #fde68a; }

        .result-box {
            background-color: #fcfcfc;
            height: auto;
            min-height: 150px;
            padding: 15px;
            white-space: pre-wrap;
            font-size: 0.9em;
        }

        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            button, select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Article Validation & Humanizer</h1>
            <p class="subtitle">Client-side paraphrasing + API-grounded reference validation.</p>
        </header>

        <div class="main">
            <div class="input-group">
                <label for="articleInput">Original Text & References</label>
                <textarea id="articleInput" placeholder="Paste your article body and reference list here. Separate the list with the heading 'REFERENCES' or 'BIBLIOGRAPHY' on a new line."></textarea>
            </div>

            <div class="controls">
                <button onclick="processArticle()" id="processBtn">
                    <span id="buttonText" class="flex items-center justify-center">
                        üöÄ Process & Validate Article
                    </span>
                    <div id="loadingSpinner" class="spinner hidden mx-auto"></div>
                </button>
                <button id="copyBtn" onclick="copyToClipboard('paraphrasedOutput')">üìã Copy Result</button>
                
                <select id="strength">
                    <option value="light">Light Rewrite</option>
                    <option value="medium" selected>Medium (Recommended)</option>
                    <option value="heavy">Heavy Rewrite</option>
                    <option value="creative">Creative Mode</option>
                </select>
            </div>

            <div class="strength-meter">
                <div class="strength-fill" id="strengthFill"></div>
            </div>

            <div id="resultsSection" class="hidden">
                 <!-- Validation and Cross-Check Summary -->
                <div id="validationSummary" class="mb-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Data will be injected here -->
                </div>

                <!-- Paraphrased Text Output -->
                <div class="output-group">
                    <label for="paraphrasedOutput">Paraphrased Text (Humanized)</label>
                    <div id="paraphrasedOutput" class="result-box" style="height: auto;">Waiting for input...</div>
                    <div class="tag-warning p-2 rounded-lg mt-2 text-xs font-medium">
                        Note: Paraphrasing uses powerful, expanded rule-based JS logic for instant, local processing.
                    </div>
                </div>

                <!-- Detailed Reference Check -->
                <div class="output-group">
                    <label>Reference & Grounding Check (API Required)</label>
                    <div id="referenceCheckOutput" class="result-box space-y-3" style="height: auto;">
                        <!-- Detailed check results will be injected here -->
                    </div>
                </div>
            </div>

            <div class="tips">
                <h3>üí° Article Prep Guide</h3>
                <ul>
                    <li>The **Paraphrasing** is instantaneous (JS-based).</li>
                    <li>**Citation Checks** (Phase 2) verify in-text author names match reference list author names.</li>
                    <li>**Reference Validation** (Phase 3) requires the Gemini API with Google Search grounding to confirm if the source titles are real.</li>
                </ul>
            </div>
        </div>

        <footer>
            <p>Built with Pure JavaScript & Gemini API Grounding. Validation requires network.</p>
        </footer>
         <div id="messageBox" class="fixed bottom-4 right-4 p-3 rounded-lg shadow-xl text-white hidden transition-opacity duration-300 z-50"></div>
    </div>

    <script>
        const API_MODEL = 'gemini-2.5-flash-preview-09-2025';
        const BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent`;
        const apiKey = ""; // Canvas will provide this

        // --- Core Synonym and Rule Database (Expanded) ---
        const synonyms = {
            "the": ["this", "that", "such", "a", "any"],
            "and": ["additionally", "plus", "furthermore", "moreover", "besides"],
            "but": ["however", "yet", "nevertheless", "nonetheless", "still", "though"],
            "because": ["since", "as", "due to", "given that", "for the reason that"],
            "very": ["extremely", "incredibly", "highly", "exceptionally", "particularly", "super", "really"],
            "good": ["excellent", "great", "superb", "outstanding", "fine", "wonderful", "solid", "decent"],
            "bad": ["poor", "terrible", "awful", "dreadful", "inferior", "subpar", "lousy"],
            "important": ["crucial", "vital", "essential", "significant", "key", "critical", "major", "fundamental"],
            "show": ["demonstrate", "illustrate", "reveal", "display", "indicate", "exhibit", "point out", "prove"],
            "use": ["utilize", "employ", "apply", "implement", "leverage", "tap into"],
            "make": ["create", "build", "produce", "generate", "develop", "construct", "formulate", "forge"],
            "get": ["obtain", "acquire", "receive", "gain", "secure", "procure", "collect"],
            "people": ["individuals", "persons", "humans", "citizens", "folks", "the masses", "public"],
            "think": ["believe", "consider", "assume", "regard", "deem", "opine", "feel", "figure"],
            "said": ["stated", "mentioned", "noted", "remarked", "declared", "expressed", "spoke", "commented"],
            "big": ["large", "huge", "enormous", "massive", "significant", "substantial", "gigantic", "sizable"],
            "small": ["tiny", "little", "minor", "slight", "diminutive", "petite", "minute", "minimal"],
            "help": ["assist", "aid", "support", "facilitate", "enable", "back up", "pitch in"],
            "problem": ["issue", "challenge", "difficulty", "obstacle", "hurdle", "complication", "dilemma"],
            "solution": ["answer", "resolution", "fix", "remedy", "key", "workaround", "way out"],
            "new": ["novel", "fresh", "recent", "modern", "innovative", "original", "unprecedented", "current"],
            "old": ["ancient", "aged", "vintage", "traditional", "long-standing", "archaic", "historic"],
            "happy": ["joyful", "delighted", "pleased", "content", "cheerful", "upbeat", "thrilled"],
            "sad": ["unhappy", "sorrowful", "depressed", "melancholy", "gloomy", "downcast", "blue"],
            "start": ["begin", "commence", "initiate", "launch", "embark", "kick off", "get underway"],
            "end": ["conclude", "finish", "terminate", "complete", "finalize", "wrap up", "cease"],
            "many": ["numerous", "several", "countless", "multiple", "a lot of", "plenty of", "scores of"],
            "few": ["scarcely any", "hardly any", "limited", "sparse", "not many", "a couple of"],
            "always": ["consistently", "invariably", "perpetually", "eternally", "all the time", "forever"],
            "never": ["not once", "at no time", "under no circumstances", "rarely", "hardly ever"],
            "can": ["is able to", "has the ability to", "could", "may", "has the capacity to"],
            "will": ["shall", "is going to", "intends to", "plans to", "is set to"],
            "should": ["ought to", "must", "needs to", "is supposed to", "had better"],
            "would": ["might", "could", "may", "is likely to", "might just"],
            "like": ["such as", "for example", "including", "similar to", "akin to", "in the way of"],
            "different": ["distinct", "unlike", "diverse", "varied", "contrasting", "separate", "dissimilar"],
            "same": ["identical", "similar", "alike", "equivalent", "comparable", "undeniably like"],
            "know": ["understand", "recognize", "comprehend", "grasp", "realize", "be aware of"],
            "way": ["method", "approach", "manner", "technique", "strategy", "tactic", "route"],
            "time": ["period", "duration", "moment", "era", "interval", "stretch"],
            "work": ["function", "operate", "perform", "labor", "task", "job", "effort"],
            "need": ["require", "demand", "necessitate", "want", "call for", "have a use for"],
            "want": ["desire", "wish", "crave", "long for", "yearn", "feel like"],
            "first": ["initial", "primary", "foremost", "leading", "premier", "starting", "original"],
            "last": ["final", "ultimate", "concluding", "ending", "closing", "terminal"],
            "next": ["following", "subsequent", "upcoming", "succeeding", "later"],
            "best": ["finest", "greatest", "top", "optimal", "premier", "superior"],
            "worst": ["poorest", "most awful", "bottom", "inferior", "lowest", "least desirable"],
            
            // Academic/Formal Language targets
            "utilize": ["use", "employ", "put to work", "apply"],
            "implement": ["start", "execute", "put in place", "roll out"],
            "consequently": ["so", "as a result", "because of that", "due to this"],
            "furthermore": ["also", "plus", "in addition", "what's more"],
            "moreover": ["plus", "besides", "as well", "on top of that"],
            "ascertain": ["figure out", "find out", "determine", "check"],
            "commence": ["start", "begin", "kick off", "get started"],
            "endeavor": ["try", "attempt", "work hard", "strive"],
            "exhibit": ["show", "display", "present", "put on view"],
            "inquire": ["ask", "check", "query", "find out"],
            "sufficient": ["enough", "plenty", "adequate", "satisfactory"],
            "numerous": ["many", "lots of", "several", "countless"],
            "determine": ["find out", "figure out", "decide", "conclude"],
            "regarding": ["about", "concerning", "on the topic of", "as for"],
            "objective": ["goal", "aim", "target", "purpose"],
            "component": ["part", "piece", "element", "section"],
            "methodology": ["method", "approach", "way", "process"],
            "involves": ["includes", "features", "has to do with", "is all about"],
            "facilitate": ["help", "make easier", "ease", "smooth the way for"],
            "subsequently": ["after that", "later", "following that", "next"],
            "prioritize": ["focus on", "put first", "make important", "handle first"],
            "demonstrate": ["show", "prove", "illustrate", "make clear"],
            "provided that": ["if", "assuming that", "on the condition that"],
            "irrespective of": ["regardless of", "no matter what", "even with"],
        };

        const restructureTemplates = [
            { pattern: /(.*) is (.*) because (.*)/, template: "Due to $3, $1 turns out to be $2" },
            { pattern: /(.*) can (.*)/, template: "$1 has the ability to $2" },
            { pattern: /(.*) will (.*)/, template: "$1 is going to $2" },
            { pattern: /It is (.*) that (.*)/, template: "What $2 reveals is $1" },
            { pattern: /(.*), which (.*)/, template: "$1 ‚Äî a factor that $2" },
            { pattern: /The (.*) of (.*) is (.*)/, template: "When it comes to $2, its $1 stands at $3" },
            { pattern: /(.*) and (.*)/, template: "Both $1 and $2" },
            { pattern: /(.*) but (.*)/, template: "Although $1, $2" },
            { pattern: /Not only (.*) but also (.*)/, template: "$1 in addition to $2" },
            // Expanded templates
            { pattern: /(.*), therefore, (.*)/, template: "$2, and the reason is $1" },
            { pattern: /(.*) is characterized by (.*)/, template: "$1 is basically all about $2" },
            { pattern: /The need for (.*) is (.*)/, template: "It‚Äôs $2 how much we need $1" },
            { pattern: /We must (.*) in order to (.*)/, template: "To $2, we simply have to $1" }
        ];

        const creativeInjections = [
            "Imagine if", "Picture this:", "Consider how", "It's fascinating that",
            "One might argue", "Surprisingly,", "In a twist,", "Remarkably,",
            "Think about it:", "What if", "This brings to mind", "Interestingly enough,",
            "You see,", "Here's the thing:", "Deep down,", "At its core,",
            "Let's be honest:", "Truth be told,", "Make no mistake:", "Without a doubt,",
            "In reality,", "Practically speaking,", "On closer inspection,",
            "Beneath the surface,", "Between the lines,", "When you dig deeper,",
            "As it turns out,", "Contrary to popular belief,",
            "It's worth noting that", "Keep in mind that", "Bear in mind,",
            "Don't overlook the fact that", "It's crucial to understand"
        ];
        // --- End of Core Synonym and Rule Database ---


        // DOM Elements
        const articleInput = document.getElementById('articleInput');
        const processBtn = document.getElementById('processBtn');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resultsSection = document.getElementById('resultsSection');
        const paraphrasedOutput = document.getElementById('paraphrasedOutput');
        const validationSummary = document.getElementById('validationSummary');
        const referenceCheckOutput = document.getElementById('referenceCheckOutput');
        const messageBox = document.getElementById('messageBox');
        const strengthSelect = document.getElementById('strength');
        const strengthFill = document.getElementById('strengthFill');

        // Update strength meter
        function updateStrengthMeter() {
            const values = { light: 30, medium: 60, heavy: 85, creative: 95 };
            strengthFill.style.width = values[strengthSelect.value] + '%';
        }
        updateStrengthMeter(); // Initialize meter

        strengthSelect.addEventListener('change', updateStrengthMeter);


        /**
         * Utility function to display a temporary message/alert.
         */
        function showMessage(text, type = 'info') {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden', 'bg-red-500', 'bg-green-500', 'bg-blue-500', 'bg-yellow-600');
            messageBox.classList.add('opacity-100');

            if (type === 'error') messageBox.classList.add('bg-red-500');
            else if (type === 'success') messageBox.classList.add('bg-green-500');
            else if (type === 'warning') messageBox.classList.add('bg-yellow-600');
            else messageBox.classList.add('bg-blue-500');

            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('hidden');
            }, 3000);
        }
        
        /**
         * Copies text from a specified element ID to the clipboard.
         */
        function copyToClipboard(elementId) {
            const text = document.getElementById(elementId).innerText;
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showMessage('Text copied to clipboard!', 'success');
                } else {
                    throw new Error('Fallback copy failed.');
                }
            } catch (err) {
                showMessage('Could not copy text. Please select and copy manually.', 'error');
            }
            document.body.removeChild(textarea);
        }

        /**
         * Generalized Gemini API caller with exponential backoff (Used only for Grounding).
         */
        async function callGemini(prompt, systemInstruction, useSearch, retries = 5) {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                config: {
                    temperature: 0.1, // Low temp for factual search
                }
            };
            if (useSearch) {
                payload.tools = [{ "google_search": {} }];
            }

            for (let i = 0; i < retries; i++) {
                try {
                    const url = `${BASE_URL}?key=${apiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text || 'Error: Could not retrieve generated text.';
                        const groundingSources = result.candidates?.[0]?.groundingMetadata?.groundingAttributions || [];
                        
                        return { text, sources: groundingSources };
                    } 
                    
                    if (i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    } else {
                        const errorBody = await response.text();
                        throw new Error(`Final API error (Status: ${response.status}): ${response.statusText}. Response body: ${errorBody.substring(0, 100)}...`);
                    }


                } catch (error) {
                    console.error('Network or unknown API error occurred:', error);
                    if (i === retries - 1) throw new Error("Failed to connect to the AI service after multiple retries. Check network connectivity.");
                    
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 500;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Rule-Based Text Transformation (Paraphrasing without API).
         */
        function ruleBasedHumanize(text, mode = 'medium') {
            if (!text.trim()) return '';

            // Split by double line breaks (paragraphs) or default to sentences
            const sections = text.split(/\n\n+/);
            let result = [];
            
            const strengthMap = { light: 0.3, medium: 0.6, heavy: 0.85, creative: 0.95 };
            const intensity = strengthMap[mode];

            sections.forEach(section => {
                let sentences = section.match(/[^\.!?]+[\.!?]+/g) || [section];
                let newSection = [];

                sentences.forEach(sentence => {
                    let words = sentence.trim().split(/\s+/);
                    let newSentence = '';
                    let wordIndex = 0;

                    // Apply sentence restructuring with probability
                    let restructured = tryRestructure(sentence.trim());
                    if (restructured && Math.random() < intensity * 0.7) {
                        newSentence = restructured;
                    } else {
                        newSentence = words.map(word => {
                            wordIndex++;
                            let cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
                            let punctuation = word.replace(/[\w]/g, '');

                            // Synonym replacement
                            if (synonyms[cleanWord] && Math.random() < intensity) {
                                let options = synonyms[cleanWord].filter(s => s !== cleanWord);
                                if (options.length > 0) {
                                    let replacement = options[Math.floor(Math.random() * options.length)];
                                    // Preserve capitalization
                                    if (wordIndex === 1 || word[0] === word[0].toUpperCase()) {
                                        replacement = replacement.charAt(0).toUpperCase() + replacement.slice(1);
                                    }
                                    return replacement + punctuation;
                                }
                            }
                            // Contraction application (simple, direct)
                            if (wordIndex > 1 && cleanWord === 'is' && words[wordIndex] === 'not') {
                                return "isn't";
                            }
                            
                            return word;
                        }).join(' ');
                    }

                    // Creative mode: inject natural phrases
                    if (mode === 'creative' && Math.random() < 0.4) {
                        const injection = creativeInjections[Math.floor(Math.random() * creativeInjections.length)];
                        newSentence = injection + ' ' + newSentence.charAt(0).toLowerCase() + newSentence.slice(1);
                    }

                    // Vary sentence length & rhythm
                    if (Math.random() < intensity * 0.5) {
                        newSentence = varySentenceStructure(newSentence);
                    }

                    // Add transitional phrases between sentences
                    if (newSection.length > 0 && Math.random() < intensity * 0.4) {
                        const transitions = ["Moreover,", "Furthermore,", "In addition,", "Similarly,", 
                                            "On the other hand,", "Conversely,", "Therefore,", "Thus,"];
                        const transition = transitions[Math.floor(Math.random() * transitions.length)];
                        newSentence = transition + ' ' + newSentence.charAt(0).toLowerCase() + newSentence.slice(1);
                    }

                    newSection.push(newSentence.trim());
                });

                let finalSection = newSection.join(' ');

                // Post-processing: fix capitalization after auto-transitions
                finalSection = finalSection.replace(/([.!?])\s*([a-z])/g, (match, p1, p2) => p1 + ' ' + p2.toUpperCase());
                finalSection = finalSection.charAt(0).toUpperCase() + finalSection.slice(1);


                result.push(finalSection);
            });

            let final = result.join('\n\n');

            // Post-processing: fix spacing around punctuation
            final = final.replace(/\s+([,.!?])/g, '$1');
            final = final.replace(/(\w)\s+([,.!?])/g, '$1$2');

            return final;
        }

        function tryRestructure(sentence) {
            for (let temp of restructureTemplates) {
                if (temp.pattern.test(sentence)) {
                    let match = sentence.match(temp.pattern);
                    if (match) {
                        let result = temp.template;
                        for (let i = 1; i < match.length; i++) {
                            result = result.replace(`$${i}`, match[i]);
                        }
                        return result;
                    }
                }
            }
            return null;
        }

        function varySentenceStructure(sentence) {
            // Split into clauses, reverse order, or combine
            if (sentence.includes(',') && Math.random() < 0.5) {
                let parts = sentence.split(',');
                if (parts.length > 1) {
                    return parts.reverse().join(' ‚Äî ').trim();
                }
            }
            if (sentence.length > 80 && Math.random() < 0.3) {
                let parts = sentence.split(/[.!?]/);
                if (parts.length > 1) {
                    return parts[0].trim() + '. And you know what else? ' + parts.slice(1).join('. ').trim();
                }
            }
            return sentence;
        }
        
        /**
         * Core function to validate a single reference using Google Search grounding.
         */
        async function validateReference(referenceTitle) {
            const systemPrompt = "Act as a verification expert. Search the web for evidence supporting the reference title provided. Confirm if the provided text appears to be a real, verifiable source (book, article, or widely accepted fact). Respond ONLY with the title of the source if you find supporting evidence, or 'UNVERIFIED' otherwise. Do not add any extra text or explanation.";
            
            try {
                const response = await callGemini(referenceTitle, systemInstruction=systemPrompt, useSearch=true, retries=5);
                
                if (response.text.toUpperCase().includes('UNVERIFIED') || response.sources.length === 0) {
                    return { status: 'UNVERIFIED', title: referenceTitle, sources: [] };
                }
                
                const realSources = response.sources.filter(s => s.web && s.web.uri);

                if (realSources.length > 0) {
                    return { status: 'VERIFIED', title: referenceTitle, sources: realSources };
                } else {
                    return { status: 'UNVERIFIED', title: referenceTitle, sources: [] };
                }

            } catch (e) {
                console.error("Validation failed for:", referenceTitle, e);
                return { status: 'ERROR', title: referenceTitle, sources: [] };
            }
        }


        /**
         * Client-side function to cross-check citations against the reference list.
         */
        function crossCheckCitations(body, references) {
            const citationRegex = /\(?[A-Z][a-z]+, \d{4}\)?|\(\d{4}\)|\[\d+\]/g; 
            const citations = [...new Set(body.match(citationRegex) || [])];
            
            let citedInText = 0;
            let unreferencedInText = 0;
            let unlinkedReferences = 0;

            const referenceTitles = references.map(ref => ref.toLowerCase().split(/[., ]+/).filter(word => word.length > 2)[0].replace(/[^a-z]/g, ''));

            // 1. Check if citations in text are in the reference list (Simplified: check for author name match)
            const citationCheck = citations.map(citation => {
                const match = citation.match(/([A-Z][a-z]+)/); 
                const author = match ? match[1].toLowerCase() : null;

                const isReferenced = author && referenceTitles.some(title => title.includes(author));

                if (isReferenced) {
                    citedInText++;
                } else {
                    unreferencedInText++;
                }
                
                return { citation, isReferenced };
            });

            // 2. Check if all references are cited in text (Simplified)
            const referenceCheck = references.map(ref => {
                const match = ref.match(/([A-Z][a-z]+)/); 
                const author = match ? match[1].toLowerCase() : null;

                const isCited = author && citationCheck.some(c => c.citation.toLowerCase().includes(author));

                if (!isCited) {
                    unlinkedReferences++;
                }

                return { reference: ref, isCited };
            });

            return {
                citationCheck,
                referenceCheck,
                citedInText,
                unreferencedInText,
                totalReferences: references.length,
                unlinkedReferences
            };
        }


        /**
         * Main function triggered by the user button.
         */
        async function processArticle() {
            const fullText = articleInput.value.trim();
            if (fullText.length < 50) {
                showMessage("Please paste a longer article text to process.", 'error');
                return;
            }

            // UI State: Disable button, show spinner
            processBtn.disabled = true;
            buttonText.textContent = "Processing (Phase 1/3)...";
            loadingSpinner.classList.remove('hidden');
            resultsSection.classList.add('hidden');
            paraphrasedOutput.textContent = "Beginning analysis...";
            validationSummary.innerHTML = "";
            referenceCheckOutput.innerHTML = "";
            
            try {
                // 1. Separate body from references
                const parts = fullText.split(/REFERENCES|BIBLIOGRAPHY|SOURCES/i);
                const body = parts[0].trim();
                const mode = strengthSelect.value;
                let references = [];

                if (parts.length > 1) {
                    references = parts[1].split('\n').map(line => line.trim()).filter(line => line.length > 5);
                }

                // --- PHASE 1: Paraphrasing (Client-Side) ---
                const paraphrased = ruleBasedHumanize(body, mode);
                paraphrasedOutput.textContent = paraphrased;
                showMessage("Phase 1: Content humanized instantly.", 'success');

                // --- PHASE 2: Cross-Check (Client-side) ---
                buttonText.textContent = "Processing (Phase 2/3)...";
                const crossCheckResults = crossCheckCitations(body, references); 
                showMessage("Phase 2: Citation Cross-Check complete.", 'success');


                // --- PHASE 3: Reference Validation (Grounding API) ---
                buttonText.textContent = "Processing (Phase 3/3 - API Call)...";
                showMessage("Phase 3: Validating references via Google Search Grounding...", 'warning');

                const validationPromises = references.map(ref => {
                    const titleSnippet = ref.split('.').slice(0, 2).join('.').trim();
                    return validateReference(titleSnippet);
                });

                const validationResults = await Promise.all(validationPromises);
                
                // --- Display Results ---
                
                // Summary Tags
                validationSummary.innerHTML = `
                    <div class="p-4 rounded-xl shadow tag-info">
                        <p class="text-xs font-bold uppercase mb-1">Total References</p>
                        <p class="text-3xl font-extrabold">${references.length}</p>
                    </div>
                    <div class="p-4 rounded-xl shadow ${crossCheckResults.unreferencedInText > 0 || crossCheckResults.unlinkedReferences > 0 ? 'tag-fail' : 'tag-success'}">
                        <p class="text-xs font-bold uppercase mb-1">Citation Match Issues</p>
                        <p class="text-3xl font-extrabold">${crossCheckResults.unreferencedInText + crossCheckResults.unlinkedReferences}</p>
                        <p class="text-xs mt-1">(${crossCheckResults.unreferencedInText} unreferenced / ${crossCheckResults.unlinkedReferences} unlinked)</p>
                    </div>
                    <div class="p-4 rounded-xl shadow ${validationResults.every(r => r.status === 'VERIFIED') ? 'tag-success' : 'tag-fail'}">
                        <p class="text-xs font-bold uppercase mb-1">References Verified</p>
                        <p class="text-3xl font-extrabold">${validationResults.filter(r => r.status === 'VERIFIED').length} / ${references.length}</p>
                    </div>
                `;

                // Detailed Cross-Check Output
                let crossCheckHtml = '<p class="font-bold text-sm mb-2 text-indigo-700">Citation Cross-Check Results:</p>';
                if (crossCheckResults.unreferencedInText > 0) {
                    crossCheckHtml += `<p class="text-sm text-red-500 mb-2">‚ùå **Unreferenced Citations:** The following in-text citations might be missing from the reference list: 
                        <span class="font-mono text-xs">${crossCheckResults.citationCheck.filter(c => !c.isReferenced).map(c => c.citation).join(', ')}</span></p>`;
                }
                if (crossCheckResults.unlinkedReferences > 0) {
                    crossCheckHtml += `<p class="text-sm text-red-500 mb-2">‚ùå **Uncited References:** The following references were not found to be cited in the article body: 
                        <span class="font-mono text-xs">${crossCheckResults.referenceCheck.filter(c => !c.isCited).map(c => c.reference.substring(0, 30) + '...').join('; ')}</span></p>`;
                }
                if (crossCheckResults.unreferencedInText === 0 && crossCheckResults.unlinkedReferences === 0) {
                    crossCheckHtml += '<p class="font-bold text-sm text-green-700">‚úÖ Cross-Check Success: All citations match and all references are cited.</p>';
                }
                referenceCheckOutput.innerHTML = `<div class="p-3 rounded-lg border-b border-gray-200">${crossCheckHtml}</div>`;


                // Detailed Validation Output
                let validationHtml = '<p class="font-bold text-sm mt-4 mb-2 text-indigo-700">Reference Grounding Verification:</p><ul class="space-y-2">';
                validationResults.forEach((result, index) => {
                    const statusClass = result.status === 'VERIFIED' ? 'tag-success' : (result.status === 'UNVERIFIED' ? 'tag-fail' : (result.status === 'ERROR' ? 'tag-fail' : 'tag-info'));
                    const statusIcon = result.status === 'VERIFIED' ? '‚úÖ' : (result.status === 'UNVERIFIED' ? '‚ö†Ô∏è' : '‚ùå');
                    
                    let sourcesHtml = '';
                    if (result.status === 'VERIFIED' && result.sources.length > 0) {
                        const firstSource = result.sources[0].web;
                        sourcesHtml = `<span class="block text-xs text-gray-500 mt-1">Found Source: <a href="${firstSource.uri}" target="_blank" class="text-indigo-500 hover:underline">${firstSource.title}</a></span>`;
                    } else if (result.status === 'UNVERIFIED') {
                         sourcesHtml = `<span class="block text-xs text-gray-500 mt-1">Grounding search could not verify a definitive, real source.</span>`;
                    } else if (result.status === 'ERROR') {
                         sourcesHtml = `<span class="block text-xs text-red-700 mt-1">Error during network call for this reference.</span>`;
                    }

                    validationHtml += `
                        <li class="p-3 rounded-xl ${statusClass}">
                            <div class="flex items-start">
                                <span class="text-lg mr-2">${statusIcon}</span>
                                <div class="flex-1">
                                    <p class="font-medium text-gray-700">${references[index]}</p>
                                    ${sourcesHtml}
                                </div>
                            </div>
                        </li>
                    `;
                });
                validationHtml += '</ul>';
                referenceCheckOutput.innerHTML += validationHtml;


                resultsSection.classList.remove('hidden');
                showMessage("Article processed successfully!", 'success');

            } catch (error) {
                console.error("An ultimate error occurred:", error);
                paraphrasedOutput.textContent = `An error occurred during final processing: ${error.message}. Please check your input and try again.`;
                showMessage("Processing failed. See console for details.", 'error');
            } finally {
                // UI State: Re-enable button, hide spinner
                processBtn.disabled = false;
                buttonText.textContent = "üöÄ Process & Validate Article";
                loadingSpinner.classList.add('hidden');
            }
        }
    </script>
</body>
</html>


